import hashlib

p = 2^252 + 27742317777372353535851937790883648493
F = GF(p)

def montgomery_to_weierstrass(A, B):
    a = 1/B^2 - A^2 / (3 * B^2)
    b = (2 * A^3 - 9 * A) / (27 * B^3)
    return (a, b)

def edwards_to_montgomery(a, d):
    A = 2 * (a + d) / (a - d)
    B = 4 / (a - d)
    return (A, B)

def edwards_add(d, x1, y1, x2, y2):
    x0 = (x1 * y2 + x2 * y1) / (1 + d * x1 * x2 * y1 * y2)
    y0 = (y1 * y2 - x1 * x2) / (1 - d * x1 * x2 * y1 * y2)
    assert x0^2 + y0^2 == 1 + d*x0^2*y0^2
    return (x0, y0)

def edwards_scale(d, s, x0, y0):
    xr = F(0)
    yr = F(1)
    xs = x0
    ys = y0

    assert x0^2 + y0^2 == 1 + d*x0^2*y0^2
    assert xr^2 + yr^2 == 1 + d*xr^2*yr^2
    assert edwards_add(d, xr, yr, x0, y0) == (x0, y0)

    s = int(s)
    while s:
        if s & 1 == 1:
            xr, yr = edwards_add(d, xr, yr, xs, ys)
        xs, ys = edwards_add(d, xs, ys, xs, ys)
        s >>= 1

    return (xr, yr)

def solve(d, x):
    y = sqrt((x^2 - 1) / (d * x^2 - 1))
    assert x^2 + y^2 == 1 + d*x^2*y^2
    return (x, y)


def point_weierstrass_to_montgomery(x, y):
    return (x / y, (x-1) / (x+1))

def point_montgomery_to_edwards(A, B, x, y):
    return (B * x - A / 3, B * y)

# x^2 y^2 = 1 + d*x^2 y^2
# x^2 y^2 - 1 = d*x^2 y^2

a = 1
d = -F(698)

cofactor = 4

A, B = edwards_to_montgomery(a, d)
a, b = montgomery_to_weierstrass(A, B)

E = EllipticCurve([a,b])
l = int(E.order() / cofactor)

assert is_prime(l)

def hash_field(s: str):
    return F(int(hashlib.sha256(s.encode('utf-8')).hexdigest(), 16))

def hash_point(d, s: str):
    n = 0
    while 1:
        x = hash_field(s + '-' + str(n))
        w = (x^2 - 1) / (d * x^2 - 1)
        if w.is_square():
            x, y = solve(d, x)
            x, y = edwards_scale(d, cofactor, x, y)

            # sanity checking
            assert (x, y) != (0, 1)
            assert edwards_scale(d, l, x, y) == (0, 1)
            return (x, y)
        else:
            n += 1


def hex_bytes(v, ll=32):
    return ','.join(['0x%02x' % x for x in v.to_bytes(ll, 'little')])

def scalar(v):
    return 'Scalar::from_bits(['+ hex_bytes(v) + '])'

def scalar_array(arr):
    return '[' + ', '.join(map(scalar, arr)) + ']'

def digits(v, pad, W):
    d = ['0x%x' % x for x in Integer(v).digits(2^W)]
    d = d + ['0'] * (pad - len(d))
    return '[%s]' % ','.join(d)

def maybe_sq_root(F):
    # precompute for square root comp.
    Q = F.order() - 1
    assert Q % 2^2 == 0
    assert Q % 2^3 != 0
    I = inverse_mod(2, Q / (2^2))

    for i in range(100):
        e = F.random_element()
        if (e^I)^2 == e:
            break

    s = e
    yield 'fn sqrt(s: Scalar) -> Option<Scalar> {'

    acc = s
    yield '    let acc = s;'

    for bit in I.bits()[::-1][1:]:
        acc = acc * acc
        yield '    let acc = acc * acc;'
        if bit:
            acc = acc * s
            yield '    let acc = acc * s;'

    assert acc == e^I

    yield '    if acc * acc == s {'
    yield '        Some(acc)'
    yield '    } else {'
    yield '        None'
    yield '    }'
    yield '}'

def window(gens):
    ds = scalar(int(d))

    W = 31
    Fp = GF(l)
    limbs = Integer(l).digits(2^W)
    barrett = floor(2^(W*(len(limbs)*2 - 1))) % l
    R = 2^(W*len(limbs))

    b_len = int(l).bit_length()

    ln = []
    ln.append('''
// Do not edit manually!
// This file was automatically generated by Sage (and cargo fmt).

use std::ops::{Add, Mul, Neg, Sub};

use curve25519_dalek::scalar::Scalar;
use gridiron::*;
use num_traits::Zero;

use sha2::Digest;
use sha2::Sha512;

use serde::{Deserialize, Serialize};

use rand_core::RngCore;
''')
    ln.append('// size of inner field in bits')
    ln.append('pub const FP_INNER_BITS: usize = %d;' % b_len)
    ln.append('')
    ln.append('// scalar field of the inner curve')
    ln.append('pub use fp_inner::Fp%d as Fp;' % b_len)
    ln.append('''
// point on inner curve
#[derive(Copy, Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]
pub struct CurvePoint {
    pub x: Scalar,
    pub y: Scalar,
}
''')
    ln.append('// p = %d' % l)
    ln.append('fp31!(')
    ln.append('    fp_inner, // name of mode')
    ln.append('    Fp%d,     // name of class' % b_len)
    ln.append('    %d,       // length of prime in bits' % b_len)
    ln.append('    %d,       // length of prime in 2^31 limbs' % len(limbs))
    ln.append('    // prime number in limbs, least significant first')
    ln.append('    %s,' % digits(l, len(limbs), W))
    ln.append('    // barrett')
    ln.append('    %s,' % digits(barrett, len(limbs), W))
    ln.append('    // montgomery R mod p')
    ln.append('    %s,' % digits(Fp(R), len(limbs), W))
    ln.append('    // montgomery R^2 mod p')
    ln.append('    %s,' % digits(Fp(R)^2, len(limbs), W))
    m = Integer(l).digits(2^31)[0]
    ln.append('    %d' % (-m).inverse_mod(2^W))
    ln.append(');')
    ln.append('')
    ln.append('pub fn param_d() -> Scalar {')
    ln.append('    Scalar::from_bits([%s])' % hex_bytes(int(d)))
    ln.append('}')
    ln.append('')
    ln += list(maybe_sq_root(F))
    ln.append('')
    ln.append('''
impl Fp {
    pub fn random<R: RngCore>(rng: &mut R) -> Self {
        let mut limbs: [u8; 32] = [0; 32];
        rng.fill_bytes(&mut limbs);
        limbs[0] = 0;
        limbs.into()
    }
}

impl Zero for CurvePoint {
    fn zero() -> Self {
        CurvePoint {
            x: Scalar::zero(),
            y: Scalar::one(),
        }
    }

    fn is_zero(&self) -> bool {
        *self == CurvePoint::zero()
    }
}

impl CurvePoint {
    pub fn on_curve(&self) -> bool {
        let x2 = self.x * self.x;
        let y2 = self.y * self.y;
        x2 + y2 == Scalar::one() + param_d() * x2 * y2
    }

    pub fn hash(val: &[u8]) -> Self {
        fn hash_cnt(val: &[u8], cnt: u32) -> Option<CurvePoint> {
            // hash (val || cnt)
            let mut hasher = Sha512::default();
            hasher.update(val);
            hasher.update(&cnt.to_le_bytes());

            // y coordinate is hash
            let y = Scalar::from_hash(hasher);

            // isolate x in x^2 + y^2 = 1 + d x^2 y^2
            let y2 = y * y;

            // sqrt(y^2 - 1)
            let y2_1 = y2 - Scalar::one();
            let y2_1_sq = sqrt(y2_1)?;

            // sqrt(d * y^2 - 1)
            let dy2_1 = param_d() * y2 - Scalar::one();
            let dy2_1_sq = sqrt(dy2_1)?;

            // x = sqrt(y^2 - 1) / sqrt(d * y^2 - 1)
            let x = y2_1_sq * dy2_1_sq.invert();
            Some(CurvePoint { x, y })
        }

        let mut cnt: u32 = 0;
        loop {
            match hash_cnt(val, cnt) {
                None => {
                    cnt += 1;
                }
                Some(p) => {
                    debug_assert!(p.on_curve());
                    break p;
                }
            }
        }
    }
}

impl Mul<CurvePoint> for Fp {
    type Output = CurvePoint;

    fn mul(self, point: CurvePoint) -> CurvePoint {
        let mut res = Zero::zero();
        let mut pow = point.clone();
        for bit in self.iter_bit().map(|b| b.0) {
            if bit == 1 {
                res = res + pow;
            }
            pow = pow + pow;
        }
        res
    }
}

impl Add for CurvePoint {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        debug_assert!(self.on_curve());
        debug_assert!(other.on_curve());
        let p = param_d() * self.x * self.y * other.x * other.y;
        let x = (self.x * other.y + other.x * self.y) * (Scalar::one() + p).invert();
        let y = (self.y * other.y - self.x * other.x) * (Scalar::one() - p).invert();
        let p = CurvePoint { x, y };
        debug_assert!(p.on_curve());
        p
    }
}

impl Sub for CurvePoint {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        self + (-other)
    }
}

impl Neg for CurvePoint {
    type Output = Self;

    fn neg(self) -> Self::Output {
        CurvePoint {
            x: -self.x,
            y: self.y,
        }
    }
}''')
    for (i, (x, y)) in enumerate(gens):
        ln.append('')
        ln.append('// random generator %d (hashed to curve)' % (i + 1))
        ln.append('pub fn g%d() -> CurvePoint {' % i)
        ln.append('    CurvePoint {')
        ln.append('        x: Scalar::from_bits([%s]),' % hex_bytes(int(x)))
        ln.append('        y: Scalar::from_bits([%s])' % hex_bytes(int(y)))
        ln.append('    }')
        ln.append('}')

    ln.append('''
#[cfg(test)]
mod tests {
    use super::*;

    use rand_core::OsRng;

    // scalar mult.: check small multiples
    #[test]
    fn test_scalar_small() {
        for i in 0..50 {
            let gi = Fp::from(i as u32) * g0();
            let mut gi_t: CurvePoint = Zero::zero();
            for _ in 0..i {
                gi_t = gi_t + g0();
            }
            assert_eq!(gi, gi_t);
        }
    }

    // scalar mult.: check associative
    #[test]
    fn test_scalar_associative() {
        for _ in 0..10 {
            let r0 = Fp::random(&mut OsRng);
            let r1 = Fp::random(&mut OsRng);
            assert_eq!((r0 + r1) * g0(), r0 * g0() + r1 * g0());
        }
    }

    // check curve inverse
    #[test]
    fn test_inv() {
        let r = Fp::random(&mut OsRng);
        let p = r * g0();
        assert_eq!(p - p, Zero::zero());
    }

    #[test]
    fn test_hash() {
        for _ in 0..10 {
            let mut msg: [u8; 64] = [0u8; 64];
            OsRng.fill_bytes(&mut msg);
            CurvePoint::hash(&msg);
        }
    }
}
''')
    return '\n'.join(ln).strip()

GENERATORS = 2

if __name__ == '__main__':

    gens = [hash_point(d, 'point%d' % i) for i in range(GENERATORS)]

    print(window(gens))
