

# This file was *autogenerated* from the file curve.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_252 = Integer(252); _sage_const_27742317777372353535851937790883648493 = Integer(27742317777372353535851937790883648493); _sage_const_1 = Integer(1); _sage_const_3 = Integer(3); _sage_const_9 = Integer(9); _sage_const_27 = Integer(27); _sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_698 = Integer(698); _sage_const_16 = Integer(16); _sage_const_32 = Integer(32); _sage_const_100 = Integer(100); _sage_const_31 = Integer(31)
import hashlib

p = _sage_const_2 **_sage_const_252  + _sage_const_27742317777372353535851937790883648493 
F = GF(p)

def montgomery_to_weierstrass(A, B):
    a = _sage_const_1 /B**_sage_const_2  - A**_sage_const_2  / (_sage_const_3  * B**_sage_const_2 )
    b = (_sage_const_2  * A**_sage_const_3  - _sage_const_9  * A) / (_sage_const_27  * B**_sage_const_3 )
    return (a, b)

def edwards_to_montgomery(a, d):
    A = _sage_const_2  * (a + d) / (a - d)
    B = _sage_const_4  / (a - d)
    return (A, B)

def edwards_add(d, x1, y1, x2, y2):
    x0 = (x1 * y2 + x2 * y1) / (_sage_const_1  + d * x1 * x2 * y1 * y2)
    y0 = (y1 * y2 - x1 * x2) / (_sage_const_1  - d * x1 * x2 * y1 * y2)
    assert x0**_sage_const_2  + y0**_sage_const_2  == _sage_const_1  + d*x0**_sage_const_2 *y0**_sage_const_2 
    return (x0, y0)

def edwards_scale(d, s, x0, y0):
    xr = F(_sage_const_0 )
    yr = F(_sage_const_1 )
    xs = x0
    ys = y0

    assert x0**_sage_const_2  + y0**_sage_const_2  == _sage_const_1  + d*x0**_sage_const_2 *y0**_sage_const_2 
    assert xr**_sage_const_2  + yr**_sage_const_2  == _sage_const_1  + d*xr**_sage_const_2 *yr**_sage_const_2 
    assert edwards_add(d, xr, yr, x0, y0) == (x0, y0)

    s = int(s)
    while s:
        if s & _sage_const_1  == _sage_const_1 :
            xr, yr = edwards_add(d, xr, yr, xs, ys)
        xs, ys = edwards_add(d, xs, ys, xs, ys)
        s >>= _sage_const_1 

    return (xr, yr)

def solve(d, x):
    y = sqrt((x**_sage_const_2  - _sage_const_1 ) / (d * x**_sage_const_2  - _sage_const_1 ))
    assert x**_sage_const_2  + y**_sage_const_2  == _sage_const_1  + d*x**_sage_const_2 *y**_sage_const_2 
    return (x, y)


def point_weierstrass_to_montgomery(x, y):
    return (x / y, (x-_sage_const_1 ) / (x+_sage_const_1 ))

def point_montgomery_to_edwards(A, B, x, y):
    return (B * x - A / _sage_const_3 , B * y)

# x^2 y^2 = 1 + d*x^2 y^2
# x^2 y^2 - 1 = d*x^2 y^2

a = _sage_const_1 
d = -F(_sage_const_698 )

cofactor = _sage_const_4 

A, B = edwards_to_montgomery(a, d)
a, b = montgomery_to_weierstrass(A, B)

E = EllipticCurve([a,b])
l = int(E.order() / cofactor)

assert is_prime(l)

def hash_field(s: str):
    return F(int(hashlib.sha256(s.encode('utf-8')).hexdigest(), _sage_const_16 ))

def hash_point(d, s: str):
    n = _sage_const_0 
    while _sage_const_1 :
        x = hash_field(s + '-' + str(n))
        w = (x**_sage_const_2  - _sage_const_1 ) / (d * x**_sage_const_2  - _sage_const_1 )
        if w.is_square():
            x, y = solve(d, x)
            x, y = edwards_scale(d, cofactor, x, y)

            # sanity checking
            assert (x, y) != (_sage_const_0 , _sage_const_1 )
            assert edwards_scale(d, l, x, y) == (_sage_const_0 , _sage_const_1 )
            return (x, y)
        else:
            n += _sage_const_1 


def hex_bytes(v, ll=_sage_const_32 ):
    return ','.join(['0x%02x' % x for x in v.to_bytes(ll, 'little')])

def scalar(v):
    return 'Scalar::from_bits(['+ hex_bytes(v) + '])'

def scalar_array(arr):
    return '[' + ', '.join(map(scalar, arr)) + ']'

def digits(v, pad, W):
    d = ['0x%x' % x for x in Integer(v).digits(_sage_const_2 **W)]
    d = d + ['0'] * (pad - len(d))
    return '[%s]' % ','.join(d)

def maybe_sq_root(F):
    # precompute for square root comp.
    Q = F.order() - _sage_const_1 
    assert Q % _sage_const_2 **_sage_const_2  == _sage_const_0 
    assert Q % _sage_const_2 **_sage_const_3  != _sage_const_0 
    I = inverse_mod(_sage_const_2 , Q / (_sage_const_2 **_sage_const_2 ))

    for i in range(_sage_const_100 ):
        e = F.random_element()
        if (e**I)**_sage_const_2  == e:
            break

    s = e
    yield 'fn sqrt(s: Scalar) -> Option<Scalar> {'

    acc = s
    yield '    let acc = s;'

    for bit in I.bits()[::-_sage_const_1 ][_sage_const_1 :]:
        acc = acc * acc
        yield '    let acc = acc * acc;'
        if bit:
            acc = acc * s
            yield '    let acc = acc * s;'

    assert acc == e**I

    yield '    if acc * acc == s {'
    yield '        Some(acc)'
    yield '    } else {'
    yield '        None'
    yield '    }'
    yield '}'

def window(gens):
    ds = scalar(int(d))

    W = _sage_const_31 
    Fp = GF(l)
    limbs = Integer(l).digits(_sage_const_2 **W)
    barrett = floor(_sage_const_2 **(W*(len(limbs)*_sage_const_2  - _sage_const_1 ))) % l
    R = _sage_const_2 **(W*len(limbs))

    b_len = int(l).bit_length()

    ln = []
    ln.append('''
// Do not edit manually!
// This file was automatically generated by Sage (and cargo fmt).

use std::ops::{Add, Mul, Neg, Sub};

use curve25519_dalek::scalar::Scalar;
use gridiron::*;
use num_traits::Zero;

use sha2::Digest;
use sha2::Sha512;

use serde::{Deserialize, Serialize};

use rand_core::RngCore;
''')
    ln.append('// size of inner field in bits')
    ln.append('pub const FP_INNER_BITS: usize = %d;' % b_len)
    ln.append('')
    ln.append('// scalar field of the inner curve')
    ln.append('pub use fp_inner::Fp%d as Fp;' % b_len)
    ln.append('''
// point on inner curve
#[derive(Copy, Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]
pub struct CurvePoint {
    pub x: Scalar,
    pub y: Scalar,
}
''')
    ln.append('// p = %d' % l)
    ln.append('fp31!(')
    ln.append('    fp_inner, // name of mode')
    ln.append('    Fp%d,     // name of class' % b_len)
    ln.append('    %d,       // length of prime in bits' % b_len)
    ln.append('    %d,       // length of prime in 2^31 limbs' % len(limbs))
    ln.append('    // prime number in limbs, least significant first')
    ln.append('    %s,' % digits(l, len(limbs), W))
    ln.append('    // barrett')
    ln.append('    %s,' % digits(barrett, len(limbs), W))
    ln.append('    // montgomery R mod p')
    ln.append('    %s,' % digits(Fp(R), len(limbs), W))
    ln.append('    // montgomery R^2 mod p')
    ln.append('    %s,' % digits(Fp(R)**_sage_const_2 , len(limbs), W))
    m = Integer(l).digits(_sage_const_2 **_sage_const_31 )[_sage_const_0 ]
    ln.append('    %d' % (-m).inverse_mod(_sage_const_2 **W))
    ln.append(');')
    ln.append('')
    ln.append('pub fn param_d() -> Scalar {')
    ln.append('    Scalar::from_bits([%s])' % hex_bytes(int(d)))
    ln.append('}')
    ln.append('')
    ln += list(maybe_sq_root(F))
    ln.append('')
    ln.append('''
impl Fp {
    pub fn random<R: RngCore>(rng: &mut R) -> Self {
        let mut limbs: [u8; 32] = [0; 32];
        rng.fill_bytes(&mut limbs);
        limbs[0] = 0;
        limbs.into()
    }
}

impl Zero for CurvePoint {
    fn zero() -> Self {
        CurvePoint {
            x: Scalar::zero(),
            y: Scalar::one(),
        }
    }

    fn is_zero(&self) -> bool {
        *self == CurvePoint::zero()
    }
}

impl CurvePoint {
    pub fn on_curve(&self) -> bool {
        let x2 = self.x * self.x;
        let y2 = self.y * self.y;
        x2 + y2 == Scalar::one() + param_d() * x2 * y2
    }

    pub fn hash(val: &[u8]) -> Self {
        fn hash_cnt(val: &[u8], cnt: u32) -> Option<CurvePoint> {
            // hash (val || cnt)
            let mut hasher = Sha512::default();
            hasher.update(val);
            hasher.update(&cnt.to_le_bytes());

            // y coordinate is hash
            let y = Scalar::from_hash(hasher);

            // isolate x in x^2 + y^2 = 1 + d x^2 y^2
            let y2 = y * y;

            // sqrt(y^2 - 1)
            let y2_1 = y2 - Scalar::one();
            let y2_1_sq = sqrt(y2_1)?;

            // sqrt(d * y^2 - 1)
            let dy2_1 = param_d() * y2 - Scalar::one();
            let dy2_1_sq = sqrt(dy2_1)?;

            // x = sqrt(y^2 - 1) / sqrt(d * y^2 - 1)
            let x = y2_1_sq * dy2_1_sq.invert();
            Some(CurvePoint { x, y })
        }

        let mut cnt: u32 = 0;
        loop {
            match hash_cnt(val, cnt) {
                None => {
                    cnt += 1;
                }
                Some(p) => {
                    debug_assert!(p.on_curve());
                    break p;
                }
            }
        }
    }
}

impl Mul<CurvePoint> for Fp {
    type Output = CurvePoint;

    fn mul(self, point: CurvePoint) -> CurvePoint {
        let mut res = Zero::zero();
        let mut pow = point.clone();
        for bit in self.iter_bit().map(|b| b.0) {
            if bit == 1 {
                res = res + pow;
            }
            pow = pow + pow;
        }
        res
    }
}

impl Add for CurvePoint {
    type Output = Self;

    fn add(self, other: Self) -> Self {
        debug_assert!(self.on_curve());
        debug_assert!(other.on_curve());
        let p = param_d() * self.x * self.y * other.x * other.y;
        let x = (self.x * other.y + other.x * self.y) * (Scalar::one() + p).invert();
        let y = (self.y * other.y - self.x * other.x) * (Scalar::one() - p).invert();
        let p = CurvePoint { x, y };
        debug_assert!(p.on_curve());
        p
    }
}

impl Sub for CurvePoint {
    type Output = Self;

    fn sub(self, other: Self) -> Self {
        self + (-other)
    }
}

impl Neg for CurvePoint {
    type Output = Self;

    fn neg(self) -> Self::Output {
        CurvePoint {
            x: -self.x,
            y: self.y,
        }
    }
}''')
    for (i, (x, y)) in enumerate(gens):
        ln.append('')
        ln.append('// random generator %d (hashed to curve)' % (i + _sage_const_1 ))
        ln.append('pub fn g%d() -> CurvePoint {' % i)
        ln.append('    CurvePoint {')
        ln.append('        x: Scalar::from_bits([%s]),' % hex_bytes(int(x)))
        ln.append('        y: Scalar::from_bits([%s])' % hex_bytes(int(y)))
        ln.append('    }')
        ln.append('}')

    ln.append('''
#[cfg(test)]
mod tests {
    use super::*;

    use rand_core::OsRng;

    // scalar mult.: check small multiples
    #[test]
    fn test_scalar_small() {
        for i in 0..50 {
            let gi = Fp::from(i as u32) * g0();
            let mut gi_t: CurvePoint = Zero::zero();
            for _ in 0..i {
                gi_t = gi_t + g0();
            }
            assert_eq!(gi, gi_t);
        }
    }

    // scalar mult.: check associative
    #[test]
    fn test_scalar_associative() {
        for _ in 0..10 {
            let r0 = Fp::random(&mut OsRng);
            let r1 = Fp::random(&mut OsRng);
            assert_eq!((r0 + r1) * g0(), r0 * g0() + r1 * g0());
        }
    }

    // check curve inverse
    #[test]
    fn test_inv() {
        let r = Fp::random(&mut OsRng);
        let p = r * g0();
        assert_eq!(p - p, Zero::zero());
    }

    #[test]
    fn test_hash() {
        for _ in 0..10 {
            let mut msg: [u8; 64] = [0u8; 64];
            OsRng.fill_bytes(&mut msg);
            CurvePoint::hash(&msg);
        }
    }
}
''')
    return '\n'.join(ln).strip()

GENERATORS = _sage_const_2 

if __name__ == '__main__':

    gens = [hash_point(d, 'point%d' % i) for i in range(GENERATORS)]

    print(window(gens))

